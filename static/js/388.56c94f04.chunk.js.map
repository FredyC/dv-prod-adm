{"version":3,"sources":["../node_modules/@material-ui/icons/esm/AddCircle.js","../node_modules/@material-ui/icons/esm/Delete.js","../../src/common.js","../../src/scope.js","../../src/es5.js","../../src/proxy.js","../../src/patches.js","../../src/immer.js","../../src/index.js","../../../src/TimePicker/TimePicker.tsx"],"names":["createSvgIcon","React","createElement","d","NOTHING","Symbol","DRAFTABLE","DRAFT_STATE","const","value","Array","proto","Object","assign","let","has","target","ownKeys","Reflect","obj","base","clone","key","desc","writable","configurable","i","cb","x","y","ImmerScope","constructor","draft","usePatches","revoke","leave","descriptors","isArray","clonePotentialDraft","each","prop","get","assertUnrevoked","peek","source","state","isDraftable","prepareCopy","createProxy","set","is","markChanged","proxyProperty","isEnumerable","scope","parent","modified","finalizing","finalized","assigned","copy","revoked","enumerable","shallowCopy","JSON","drafts","hasArrayChanges","hasObjectChanges","keys","baseValue","descriptor","isDraft","result","markChangesSweep","object","markChangesRecursively","Proxy","proxy","objectTraps","owner","defineProperty","getPrototypeOf","setPrototypeOf","arrayTraps","arguments","fn","isNaN","parseInt","patches","inversePatches","delta","start","end","path","basePath","op","useRemove","replaceCount","length","generateArrayPatches","origValue","generateObjectPatches","patch","configDefaults","useProxies","autoFreeze","verifyMinified","onAssign","onDelete","onCopy","Immer","produce","defaultBase","self","recipe","call","patchListener","hasError","this","error","produceWithPatches","arg1","createDraft","finishDraft","setAutoFreeze","setUseProxies","applyPatches","processResult","baseDraft","isReplaced","finalize","generatePatches","finalizeTree","root","needPatches","finalizeProperty","Error","isDraftProp","rootPath","immer","defaultProps","openTo","views","useOptions","props","utils","useUtils","getDefaultFormat","pick12hOr24hFormat","time24hFormat","TimePicker","makePickerWithState","Input","useState","DefaultToolbarComponent","TimePickerToolbar","KeyboardTimePicker","getCustomProps","refuse"],"mappings":"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","file":"static/js/388.56c94f04.chunk.js","sourcesContent":["import React from 'react';\nimport createSvgIcon from './utils/createSvgIcon';\nexport default createSvgIcon(React.createElement(\"path\", {\n  d: \"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z\"\n}), 'AddCircle');","import React from 'react';\nimport createSvgIcon from './utils/createSvgIcon';\nexport default createSvgIcon(React.createElement(\"path\", {\n  d: \"M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z\"\n}), 'Delete');","var obj;\nvar NOTHING = typeof Symbol !== \"undefined\" ? Symbol(\"immer-nothing\") : ( obj = {}, obj[\"immer-nothing\"] = true, obj );\nvar DRAFTABLE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-state\") : \"__$immer_state\";\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\nfunction isDraftable(value) {\n  if (!value || typeof value !== \"object\") { return false; }\n  if (Array.isArray(value)) { return true; }\n  var proto = Object.getPrototypeOf(value);\n  if (!proto || proto === Object.prototype) { return true; }\n  return !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE];\n}\nfunction original(value) {\n  if (value && value[DRAFT_STATE]) {\n    return value[DRAFT_STATE].base;\n  } // otherwise return undefined\n\n}\nvar assign = Object.assign || function assign(target, value) {\n  for (var key in value) {\n    if (has(value, key)) {\n      target[key] = value[key];\n    }\n  }\n\n  return target;\n};\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function (obj) { return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj)); } : Object.getOwnPropertyNames;\nfunction shallowCopy(base, invokeGetters) {\n  if ( invokeGetters === void 0 ) invokeGetters = false;\n\n  if (Array.isArray(base)) { return base.slice(); }\n  var clone = Object.create(Object.getPrototypeOf(base));\n  ownKeys(base).forEach(function (key) {\n    if (key === DRAFT_STATE) {\n      return; // Never copy over draft state.\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(base, key);\n    var value = desc.value;\n\n    if (desc.get) {\n      if (!invokeGetters) {\n        throw new Error(\"Immer drafts cannot have computed properties\");\n      }\n\n      value = desc.get.call(base);\n    }\n\n    if (desc.enumerable) {\n      clone[key] = value;\n    } else {\n      Object.defineProperty(clone, key, {\n        value: value,\n        writable: true,\n        configurable: true\n      });\n    }\n  });\n  return clone;\n}\nfunction each(value, cb) {\n  if (Array.isArray(value)) {\n    for (var i = 0; i < value.length; i++) { cb(i, value[i], value); }\n  } else {\n    ownKeys(value).forEach(function (key) { return cb(key, value[key], value); });\n  }\n}\nfunction isEnumerable(base, prop) {\n  var desc = Object.getOwnPropertyDescriptor(base, prop);\n  return !!desc && desc.enumerable;\n}\nfunction has(thing, prop) {\n  return Object.prototype.hasOwnProperty.call(thing, prop);\n}\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\n/** Each scope represents a `produce` call. */\n\nvar ImmerScope = function ImmerScope(parent) {\n  this.drafts = [];\n  this.parent = parent; // Whenever the modified draft contains a draft from another scope, we\n  // need to prevent auto-freezing so the unowned draft can be finalized.\n\n  this.canAutoFreeze = true; // To avoid prototype lookups:\n\n  this.patches = null;\n};\n\nImmerScope.prototype.usePatches = function usePatches (patchListener) {\n  if (patchListener) {\n    this.patches = [];\n    this.inversePatches = [];\n    this.patchListener = patchListener;\n  }\n};\n\nImmerScope.prototype.revoke = function revoke$1 () {\n  this.leave();\n  this.drafts.forEach(revoke);\n  this.drafts = null; // Make draft-related methods throw.\n};\n\nImmerScope.prototype.leave = function leave () {\n  if (this === ImmerScope.current) {\n    ImmerScope.current = this.parent;\n  }\n};\nImmerScope.current = null;\n\nImmerScope.enter = function () {\n  return this.current = new ImmerScope(this.current);\n};\n\nfunction revoke(draft) {\n  draft[DRAFT_STATE].revoke();\n}\n\n// but share them all instead\n\nvar descriptors = {};\nfunction willFinalize(scope, result, isReplaced) {\n  scope.drafts.forEach(function (draft) {\n    draft[DRAFT_STATE].finalizing = true;\n  });\n\n  if (!isReplaced) {\n    if (scope.patches) {\n      markChangesRecursively(scope.drafts[0]);\n    } // This is faster when we don't care about which attributes changed.\n\n\n    markChangesSweep(scope.drafts);\n  } // When a child draft is returned, look for changes.\n  else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n      markChangesSweep(scope.drafts);\n    }\n}\nfunction createProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var draft = clonePotentialDraft(base);\n  each(draft, function (prop) {\n    proxyProperty(draft, prop, isArray || isEnumerable(base, prop));\n  }); // See \"proxy.js\" for property documentation.\n\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    scope: scope,\n    modified: false,\n    finalizing: false,\n    // es5 only\n    finalized: false,\n    assigned: {},\n    parent: parent,\n    base: base,\n    draft: draft,\n    copy: null,\n    revoke: revoke$1,\n    revoked: false // es5 only\n\n  };\n  createHiddenProperty(draft, DRAFT_STATE, state);\n  scope.drafts.push(draft);\n  return draft;\n}\n\nfunction revoke$1() {\n  this.revoked = true;\n}\n\nfunction source(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n\n  if (state && !state.finalizing) {\n    state.finalizing = true;\n    var value = draft[prop];\n    state.finalizing = false;\n    return value;\n  }\n\n  return draft[prop];\n}\n\nfunction get(state, prop) {\n  assertUnrevoked(state);\n  var value = peek(source(state), prop);\n  if (state.finalizing) { return value; } // Create a draft if the value is unmodified.\n\n  if (value === peek(state.base, prop) && isDraftable(value)) {\n    prepareCopy(state);\n    return state.copy[prop] = createProxy(value, state);\n  }\n\n  return value;\n}\n\nfunction set(state, prop, value) {\n  assertUnrevoked(state);\n  state.assigned[prop] = true;\n\n  if (!state.modified) {\n    if (is(value, peek(source(state), prop))) { return; }\n    markChanged(state);\n    prepareCopy(state);\n  }\n\n  state.copy[prop] = value;\n}\n\nfunction markChanged(state) {\n  if (!state.modified) {\n    state.modified = true;\n    if (state.parent) { markChanged(state.parent); }\n  }\n}\n\nfunction prepareCopy(state) {\n  if (!state.copy) { state.copy = clonePotentialDraft(state.base); }\n}\n\nfunction clonePotentialDraft(base) {\n  var state = base && base[DRAFT_STATE];\n\n  if (state) {\n    state.finalizing = true;\n    var draft = shallowCopy(state.draft, true);\n    state.finalizing = false;\n    return draft;\n  }\n\n  return shallowCopy(base);\n}\n\nfunction proxyProperty(draft, prop, enumerable) {\n  var desc = descriptors[prop];\n\n  if (desc) {\n    desc.enumerable = enumerable;\n  } else {\n    descriptors[prop] = desc = {\n      configurable: true,\n      enumerable: enumerable,\n\n      get: function get$1() {\n        return get(this[DRAFT_STATE], prop);\n      },\n\n      set: function set$1(value) {\n        set(this[DRAFT_STATE], prop, value);\n      }\n\n    };\n  }\n\n  Object.defineProperty(draft, prop, desc);\n}\n\nfunction assertUnrevoked(state) {\n  if (state.revoked === true) { throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(source(state))); }\n} // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\n\nfunction markChangesSweep(drafts) {\n  // The natural order of drafts in the `scope` array is based on when they\n  // were accessed. By processing drafts in reverse natural order, we have a\n  // better chance of processing leaf nodes first. When a leaf node is known to\n  // have changed, we can avoid any traversal of its ancestor nodes.\n  for (var i = drafts.length - 1; i >= 0; i--) {\n    var state = drafts[i][DRAFT_STATE];\n\n    if (!state.modified) {\n      if (Array.isArray(state.base)) {\n        if (hasArrayChanges(state)) { markChanged(state); }\n      } else if (hasObjectChanges(state)) { markChanged(state); }\n    }\n  }\n}\n\nfunction markChangesRecursively(object) {\n  if (!object || typeof object !== \"object\") { return; }\n  var state = object[DRAFT_STATE];\n  if (!state) { return; }\n  var base = state.base;\n  var draft = state.draft;\n  var assigned = state.assigned;\n\n  if (!Array.isArray(object)) {\n    // Look for added keys.\n    Object.keys(draft).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (base[key] === undefined && !has(base, key)) {\n        assigned[key] = true;\n        markChanged(state);\n      } else if (!assigned[key]) {\n        // Only untouched properties trigger recursion.\n        markChangesRecursively(draft[key]);\n      }\n    }); // Look for removed keys.\n\n    Object.keys(base).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (draft[key] === undefined && !has(draft, key)) {\n        assigned[key] = false;\n        markChanged(state);\n      }\n    });\n  } else if (hasArrayChanges(state)) {\n    markChanged(state);\n    assigned.length = true;\n\n    if (draft.length < base.length) {\n      for (var i = draft.length; i < base.length; i++) { assigned[i] = false; }\n    } else {\n      for (var i$1 = base.length; i$1 < draft.length; i$1++) { assigned[i$1] = true; }\n    }\n\n    for (var i$2 = 0; i$2 < draft.length; i$2++) {\n      // Only untouched indices trigger recursion.\n      if (assigned[i$2] === undefined) { markChangesRecursively(draft[i$2]); }\n    }\n  }\n}\n\nfunction hasObjectChanges(state) {\n  var base = state.base;\n  var draft = state.draft; // Search for added keys and changed keys. Start at the back, because\n  // non-numeric keys are ordered by time of definition on the object.\n\n  var keys = Object.keys(draft);\n\n  for (var i = keys.length - 1; i >= 0; i--) {\n    var key = keys[i];\n    var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.\n\n    if (baseValue === undefined && !has(base, key)) {\n      return true;\n    } // Once a base key is deleted, future changes go undetected, because its\n    // descriptor is erased. This branch detects any missed changes.\n    else {\n        var value = draft[key];\n        var state$1 = value && value[DRAFT_STATE];\n\n        if (state$1 ? state$1.base !== baseValue : !is(value, baseValue)) {\n          return true;\n        }\n      }\n  } // At this point, no keys were added or changed.\n  // Compare key count to determine if keys were deleted.\n\n\n  return keys.length !== Object.keys(base).length;\n}\n\nfunction hasArrayChanges(state) {\n  var draft = state.draft;\n  if (draft.length !== state.base.length) { return true; } // See #116\n  // If we first shorten the length, our array interceptors will be removed.\n  // If after that new items are added, result in the same original length,\n  // those last items will have no intercepting property.\n  // So if there is no own descriptor on the last position, we know that items were removed and added\n  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n  // the last one\n\n  var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n  if (descriptor && !descriptor.get) { return true; } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n  return false;\n}\n\nfunction createHiddenProperty(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value: value,\n    enumerable: false,\n    writable: true\n  });\n}\n\nvar legacyProxy = /*#__PURE__*/Object.freeze({\n\twillFinalize: willFinalize,\n\tcreateProxy: createProxy\n});\n\nfunction willFinalize$1() {}\nfunction createProxy$1(base, parent) {\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    // Track which produce call this is associated with.\n    scope: scope,\n    // True for both shallow and deep changes.\n    modified: false,\n    // Used during finalization.\n    finalized: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned: {},\n    // The parent draft state.\n    parent: parent,\n    // The base state.\n    base: base,\n    // The base proxy.\n    draft: null,\n    // Any property proxies.\n    drafts: {},\n    // The base copy with any updated values.\n    copy: null,\n    // Called by the `produce` function.\n    revoke: null\n  };\n  var ref = Array.isArray(base) ? // [state] is used for arrays, to make sure the proxy is array-ish and not violate invariants,\n  // although state itself is an object\n  Proxy.revocable([state], arrayTraps) : Proxy.revocable(state, objectTraps);\n  var revoke = ref.revoke;\n  var proxy = ref.proxy;\n  state.draft = proxy;\n  state.revoke = revoke;\n  scope.drafts.push(proxy);\n  return proxy;\n}\nvar objectTraps = {\n  get: get$1,\n\n  has: function has(target, prop) {\n    return prop in source$1(target);\n  },\n\n  ownKeys: function ownKeys(target) {\n    return Reflect.ownKeys(source$1(target));\n  },\n\n  set: set$1,\n  deleteProperty: deleteProperty,\n  getOwnPropertyDescriptor: getOwnPropertyDescriptor,\n\n  defineProperty: function defineProperty() {\n    throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\"); // prettier-ignore\n  },\n\n  getPrototypeOf: function getPrototypeOf(target) {\n    return Object.getPrototypeOf(target.base);\n  },\n\n  setPrototypeOf: function setPrototypeOf() {\n    throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n  }\n\n};\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if (isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports deleting array indices\"); // prettier-ignore\n  }\n\n  return objectTraps.deleteProperty.call(this, state[0], prop);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if (prop !== \"length\" && isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports setting array indices and the 'length' property\"); // prettier-ignore\n  }\n\n  return objectTraps.set.call(this, state[0], prop, value);\n}; // returns the object we should be reading the current value from, which is base, until some change has been made\n\n\nfunction source$1(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek$1(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var desc = Reflect.getOwnPropertyDescriptor(state ? source$1(state) : draft, prop);\n  return desc && desc.value;\n}\n\nfunction get$1(state, prop) {\n  if (prop === DRAFT_STATE) { return state; }\n  var drafts = state.drafts; // Check for existing draft in unmodified state.\n\n  if (!state.modified && has(drafts, prop)) {\n    return drafts[prop];\n  }\n\n  var value = source$1(state)[prop];\n\n  if (state.finalized || !isDraftable(value)) {\n    return value;\n  } // Check for existing draft in modified state.\n\n\n  if (state.modified) {\n    // Assigned values are never drafted. This catches any drafts we created, too.\n    if (value !== peek$1(state.base, prop)) { return value; } // Store drafts on the copy (when one exists).\n\n    drafts = state.copy;\n  }\n\n  return drafts[prop] = createProxy$1(value, state);\n}\n\nfunction set$1(state, prop, value) {\n  if (!state.modified) {\n    var baseValue = peek$1(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to\n    // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n    // values may be drafts, but falsy values are never drafts.\n\n    var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;\n    if (isUnchanged) { return true; }\n    markChanged$1(state);\n  }\n\n  state.assigned[prop] = true;\n  state.copy[prop] = value;\n  return true;\n}\n\nfunction deleteProperty(state, prop) {\n  // The `undefined` check is a fast path for pre-existing keys.\n  if (peek$1(state.base, prop) !== undefined || prop in state.base) {\n    state.assigned[prop] = false;\n    markChanged$1(state);\n  } else if (state.assigned[prop]) {\n    // if an originally not assigned property was deleted\n    delete state.assigned[prop];\n  }\n\n  if (state.copy) { delete state.copy[prop]; }\n  return true;\n} // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n// the same guarantee in ES5 mode.\n\n\nfunction getOwnPropertyDescriptor(state, prop) {\n  var owner = source$1(state);\n  var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n\n  if (desc) {\n    desc.writable = true;\n    desc.configurable = !Array.isArray(owner) || prop !== \"length\";\n  }\n\n  return desc;\n}\n\nfunction markChanged$1(state) {\n  if (!state.modified) {\n    state.modified = true;\n    state.copy = assign(shallowCopy(state.base), state.drafts);\n    state.drafts = null;\n    if (state.parent) { markChanged$1(state.parent); }\n  }\n}\n\nvar modernProxy = /*#__PURE__*/Object.freeze({\n\twillFinalize: willFinalize$1,\n\tcreateProxy: createProxy$1\n});\n\nfunction generatePatches(state, basePath, patches, inversePatches) {\n  Array.isArray(state.base) ? generateArrayPatches(state, basePath, patches, inversePatches) : generateObjectPatches(state, basePath, patches, inversePatches);\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n  var assign, assign$1;\n\n  var base = state.base;\n  var copy = state.copy;\n  var assigned = state.assigned; // Reduce complexity by ensuring `base` is never longer.\n\n  if (copy.length < base.length) {\n    (assign = [copy, base], base = assign[0], copy = assign[1]);\n    (assign$1 = [inversePatches, patches], patches = assign$1[0], inversePatches = assign$1[1]);\n  }\n\n  var delta = copy.length - base.length; // Find the first replaced index.\n\n  var start = 0;\n\n  while (base[start] === copy[start] && start < base.length) {\n    ++start;\n  } // Find the last replaced index. Search from the end to optimize splice patches.\n\n\n  var end = base.length;\n\n  while (end > start && base[end - 1] === copy[end + delta - 1]) {\n    --end;\n  } // Process replaced indices.\n\n\n  for (var i = start; i < end; ++i) {\n    if (assigned[i] && copy[i] !== base[i]) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"replace\",\n        path: path,\n        value: copy[i]\n      });\n      inversePatches.push({\n        op: \"replace\",\n        path: path,\n        value: base[i]\n      });\n    }\n  }\n\n  var useRemove = end != base.length;\n  var replaceCount = patches.length; // Process added indices.\n\n  for (var i$1 = end + delta - 1; i$1 >= end; --i$1) {\n    var path$1 = basePath.concat([i$1]);\n    patches[replaceCount + i$1 - end] = {\n      op: \"add\",\n      path: path$1,\n      value: copy[i$1]\n    };\n\n    if (useRemove) {\n      inversePatches.push({\n        op: \"remove\",\n        path: path$1\n      });\n    }\n  } // One \"replace\" patch reverses all non-splicing \"add\" patches.\n\n\n  if (!useRemove) {\n    inversePatches.push({\n      op: \"replace\",\n      path: basePath.concat([\"length\"]),\n      value: base.length\n    });\n  }\n}\n\nfunction generateObjectPatches(state, basePath, patches, inversePatches) {\n  var base = state.base;\n  var copy = state.copy;\n  each(state.assigned, function (key, assignedValue) {\n    var origValue = base[key];\n    var value = copy[key];\n    var op = !assignedValue ? \"remove\" : key in base ? \"replace\" : \"add\";\n    if (origValue === value && op === \"replace\") { return; }\n    var path = basePath.concat(key);\n    patches.push(op === \"remove\" ? {\n      op: op,\n      path: path\n    } : {\n      op: op,\n      path: path,\n      value: value\n    });\n    inversePatches.push(op === \"add\" ? {\n      op: \"remove\",\n      path: path\n    } : op === \"remove\" ? {\n      op: \"add\",\n      path: path,\n      value: origValue\n    } : {\n      op: \"replace\",\n      path: path,\n      value: origValue\n    });\n  });\n}\n\nfunction applyPatches(draft, patches) {\n  // First, find a patch that replaces the entire state, if found, we don't have to apply earlier patches and modify the state\n  for (var i = 0; i < patches.length; i++) {\n    var patch = patches[i];\n    var path = patch.path;\n    if (!path.length) { throw new Error(\"Illegal state\"); }\n    var base = draft;\n\n    for (var i$1 = 0; i$1 < path.length - 1; i$1++) {\n      base = base[path[i$1]];\n      if (!base || typeof base !== \"object\") { throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")); } // prettier-ignore\n    }\n\n    var key = path[path.length - 1];\n\n    switch (patch.op) {\n      case \"replace\":\n        base[key] = patch.value;\n        break;\n\n      case \"add\":\n        if (Array.isArray(base)) {\n          // TODO: support \"foo/-\" paths for appending to an array\n          base.splice(key, 0, patch.value);\n        } else {\n          base[key] = patch.value;\n        }\n\n        break;\n\n      case \"remove\":\n        if (Array.isArray(base)) {\n          base.splice(key, 1);\n        } else {\n          delete base[key];\n        }\n\n        break;\n\n      default:\n        throw new Error(\"Unsupported patch operation: \" + patch.op);\n    }\n  }\n\n  return draft;\n}\n\nfunction verifyMinified() {}\n\nvar configDefaults = {\n  useProxies: typeof Proxy !== \"undefined\" && typeof Reflect !== \"undefined\",\n  autoFreeze: typeof process !== \"undefined\" ? process.env.NODE_ENV !== \"production\" : verifyMinified.name === \"verifyMinified\",\n  onAssign: null,\n  onDelete: null,\n  onCopy: null\n};\nvar Immer = function Immer(config) {\n  assign(this, configDefaults, config);\n  this.setUseProxies(this.useProxies);\n  this.produce = this.produce.bind(this);\n};\n\nImmer.prototype.produce = function produce (base, recipe, patchListener) {\n    var this$1 = this;\n\n  // curried invocation\n  if (typeof base === \"function\" && typeof recipe !== \"function\") {\n    var defaultBase = recipe;\n    recipe = base;\n    var self = this;\n    return function curriedProduce(base) {\n        var this$1 = this;\n        if ( base === void 0 ) base = defaultBase;\n        var args = [], len = arguments.length - 1;\n        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n      return self.produce(base, function (draft) { return recipe.call.apply(recipe, [ this$1, draft ].concat( args )); }); // prettier-ignore\n    };\n  } // prettier-ignore\n\n\n  {\n    if (typeof recipe !== \"function\") {\n      throw new Error(\"The first or second argument to `produce` must be a function\");\n    }\n\n    if (patchListener !== undefined && typeof patchListener !== \"function\") {\n      throw new Error(\"The third argument to `produce` must be a function or undefined\");\n    }\n  }\n  var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n\n  if (isDraftable(base)) {\n    var scope = ImmerScope.enter();\n    var proxy = this.createProxy(base);\n    var hasError = true;\n\n    try {\n      result = recipe(proxy);\n      hasError = false;\n    } finally {\n      // finally instead of catch + rethrow better preserves original stack\n      if (hasError) { scope.revoke(); }else { scope.leave(); }\n    }\n\n    if (result instanceof Promise) {\n      return result.then(function (result) {\n        scope.usePatches(patchListener);\n        return this$1.processResult(result, scope);\n      }, function (error) {\n        scope.revoke();\n        throw error;\n      });\n    }\n\n    scope.usePatches(patchListener);\n    return this.processResult(result, scope);\n  } else {\n    result = recipe(base);\n    if (result === undefined) { return base; }\n    return result !== NOTHING ? result : undefined;\n  }\n};\n\nImmer.prototype.produceWithPatches = function produceWithPatches (arg1, arg2, arg3) {\n    var this$1 = this;\n\n  if (typeof arg1 === \"function\") {\n    return function (state) {\n        var args = [], len = arguments.length - 1;\n        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n        return this$1.produceWithPatches(state, function (draft) { return arg1.apply(void 0, [ draft ].concat( args )); });\n      };\n  } // non-curried form\n\n\n  if (arg3) { throw new Error(\"A patch listener cannot be passed to produceWithPatches\"); }\n  var patches, inversePatches;\n  var nextState = this.produce(arg1, arg2, function (p, ip) {\n    patches = p;\n    inversePatches = ip;\n  });\n  return [nextState, patches, inversePatches];\n};\n\nImmer.prototype.createDraft = function createDraft (base) {\n  if (!isDraftable(base)) {\n    throw new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\"); // prettier-ignore\n  }\n\n  var scope = ImmerScope.enter();\n  var proxy = this.createProxy(base);\n  proxy[DRAFT_STATE].isManual = true;\n  scope.leave();\n  return proxy;\n};\n\nImmer.prototype.finishDraft = function finishDraft (draft, patchListener) {\n  var state = draft && draft[DRAFT_STATE];\n\n  if (!state || !state.isManual) {\n    throw new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\"); // prettier-ignore\n  }\n\n  if (state.finalized) {\n    throw new Error(\"The given draft is already finalized\"); // prettier-ignore\n  }\n\n  var scope = state.scope;\n  scope.usePatches(patchListener);\n  return this.processResult(undefined, scope);\n};\n\nImmer.prototype.setAutoFreeze = function setAutoFreeze (value) {\n  this.autoFreeze = value;\n};\n\nImmer.prototype.setUseProxies = function setUseProxies (value) {\n  this.useProxies = value;\n  assign(this, value ? modernProxy : legacyProxy);\n};\n\nImmer.prototype.applyPatches = function applyPatches$1 (base, patches) {\n  // If a patch replaces the entire state, take that replacement as base\n  // before applying patches\n  var i;\n\n  for (i = patches.length - 1; i >= 0; i--) {\n    var patch = patches[i];\n\n    if (patch.path.length === 0 && patch.op === \"replace\") {\n      base = patch.value;\n      break;\n    }\n  }\n\n  if (isDraft(base)) {\n    // N.B: never hits if some patch a replacement, patches are never drafts\n    return applyPatches(base, patches);\n  } // Otherwise, produce a copy of the base state.\n\n\n  return this.produce(base, function (draft) { return applyPatches(draft, patches.slice(i + 1)); });\n};\n/** @internal */\n\n\nImmer.prototype.processResult = function processResult (result, scope) {\n  var baseDraft = scope.drafts[0];\n  var isReplaced = result !== undefined && result !== baseDraft;\n  this.willFinalize(scope, result, isReplaced);\n\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified) {\n      scope.revoke();\n      throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"); // prettier-ignore\n    }\n\n    if (isDraftable(result)) {\n      // Finalize the result in case it contains (or is) a subset of the draft.\n      result = this.finalize(result, null, scope);\n    }\n\n    if (scope.patches) {\n      scope.patches.push({\n        op: \"replace\",\n        path: [],\n        value: result\n      });\n      scope.inversePatches.push({\n        op: \"replace\",\n        path: [],\n        value: baseDraft[DRAFT_STATE].base\n      });\n    }\n  } else {\n    // Finalize the base draft.\n    result = this.finalize(baseDraft, [], scope);\n  }\n\n  scope.revoke();\n\n  if (scope.patches) {\n    scope.patchListener(scope.patches, scope.inversePatches);\n  }\n\n  return result !== NOTHING ? result : undefined;\n};\n/**\n * @internal\n * Finalize a draft, returning either the unmodified base state or a modified\n * copy of the base state.\n */\n\n\nImmer.prototype.finalize = function finalize (draft, path, scope) {\n    var this$1 = this;\n\n  var state = draft[DRAFT_STATE];\n\n  if (!state) {\n    if (Object.isFrozen(draft)) { return draft; }\n    return this.finalizeTree(draft, null, scope);\n  } // Never finalize drafts owned by another scope.\n\n\n  if (state.scope !== scope) {\n    return draft;\n  }\n\n  if (!state.modified) {\n    return state.base;\n  }\n\n  if (!state.finalized) {\n    state.finalized = true;\n    this.finalizeTree(state.draft, path, scope);\n\n    if (this.onDelete) {\n      // The `assigned` object is unreliable with ES5 drafts.\n      if (this.useProxies) {\n        var assigned = state.assigned;\n\n        for (var prop in assigned) {\n          if (!assigned[prop]) { this.onDelete(state, prop); }\n        }\n      } else {\n        var base = state.base;\n          var copy = state.copy;\n        each(base, function (prop) {\n          if (!has(copy, prop)) { this$1.onDelete(state, prop); }\n        });\n      }\n    }\n\n    if (this.onCopy) {\n      this.onCopy(state);\n    } // At this point, all descendants of `state.copy` have been finalized,\n    // so we can be sure that `scope.canAutoFreeze` is accurate.\n\n\n    if (this.autoFreeze && scope.canAutoFreeze) {\n      Object.freeze(state.copy);\n    }\n\n    if (path && scope.patches) {\n      generatePatches(state, path, scope.patches, scope.inversePatches);\n    }\n  }\n\n  return state.copy;\n};\n/**\n * @internal\n * Finalize all drafts in the given state tree.\n */\n\n\nImmer.prototype.finalizeTree = function finalizeTree (root, rootPath, scope) {\n    var this$1 = this;\n\n  var state = root[DRAFT_STATE];\n\n  if (state) {\n    if (!this.useProxies) {\n      // Create the final copy, with added keys and without deleted keys.\n      state.copy = shallowCopy(state.draft, true);\n    }\n\n    root = state.copy;\n  }\n\n  var needPatches = !!rootPath && !!scope.patches;\n\n  var finalizeProperty = function (prop, value, parent) {\n    if (value === parent) {\n      throw Error(\"Immer forbids circular references\");\n    } // In the `finalizeTree` method, only the `root` object may be a draft.\n\n\n    var isDraftProp = !!state && parent === root;\n\n    if (isDraft(value)) {\n      var path = isDraftProp && needPatches && !state.assigned[prop] ? rootPath.concat(prop) : null; // Drafts owned by `scope` are finalized here.\n\n      value = this$1.finalize(value, path, scope); // Drafts from another scope must prevent auto-freezing.\n\n      if (isDraft(value)) {\n        scope.canAutoFreeze = false;\n      } // Preserve non-enumerable properties.\n\n\n      if (Array.isArray(parent) || isEnumerable(parent, prop)) {\n        parent[prop] = value;\n      } else {\n        Object.defineProperty(parent, prop, {\n          value: value\n        });\n      } // Unchanged drafts are never passed to the `onAssign` hook.\n\n\n      if (isDraftProp && value === state.base[prop]) { return; }\n    } // Unchanged draft properties are ignored.\n    else if (isDraftProp && is(value, state.base[prop])) {\n        return;\n      } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n      else if (isDraftable(value) && !Object.isFrozen(value)) {\n          each(value, finalizeProperty);\n        }\n\n    if (isDraftProp && this$1.onAssign) {\n      this$1.onAssign(state, prop, value);\n    }\n  };\n\n  each(root, finalizeProperty);\n  return root;\n};\n\nvar immer = new Immer();\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\n\nvar produce = immer.produce;\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\n\nvar produceWithPatches = immer.produceWithPatches.bind(immer);\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\n\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\n\nvar setUseProxies = immer.setUseProxies.bind(immer);\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\n\nvar applyPatches$1 = immer.applyPatches.bind(immer);\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\n\nvar createDraft = immer.createDraft.bind(immer);\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\n\nvar finishDraft = immer.finishDraft.bind(immer);\n\nexport default produce;\nexport { Immer, applyPatches$1 as applyPatches, createDraft, finishDraft, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies };\n//# sourceMappingURL=immer.module.js.map\n",null,null,null,null,null,null,"import { useUtils } from '../_shared/hooks/useUtils';\nimport { TimePickerToolbar } from './TimePickerToolbar';\nimport { PureDateInput } from '../_shared/PureDateInput';\nimport { KeyboardDateInput } from '../_shared/KeyboardDateInput';\nimport { timePickerDefaultProps } from '../constants/prop-types';\nimport { usePickerState } from '../_shared/hooks/usePickerState';\nimport { pick12hOr24hFormat } from '../_helpers/text-field-helper';\nimport { useKeyboardPickerState } from '../_shared/hooks/useKeyboardPickerState';\nimport {\n  WithKeyboardInputProps,\n  makePickerWithState,\n  WithPureInputProps,\n} from '../Picker/makePickerWithState';\n\ntype TimePickerView = 'hours' | 'minutes' | 'seconds';\n\nexport interface BaseTimePickerProps {\n  /**\n   * 12h/24h view for hour selection clock\n   * @default true\n   */\n  ampm?: boolean;\n  /**\n   * Step over minutes\n   * @default 1\n   */\n  minutesStep?: number;\n}\n\nexport interface TimePickerViewsProps extends BaseTimePickerProps {\n  /** Array of views to show */\n  views?: ('hours' | 'minutes' | 'seconds')[];\n  /** First view to show in timepicker */\n  openTo?: 'hours' | 'minutes' | 'seconds';\n}\n\nexport type TimePickerProps = WithPureInputProps & TimePickerViewsProps;\n\nexport type KeyboardTimePickerProps = WithKeyboardInputProps & TimePickerViewsProps;\n\nconst defaultProps = {\n  ...timePickerDefaultProps,\n  openTo: 'hours' as TimePickerView,\n  views: ['hours', 'minutes'] as TimePickerView[],\n};\n\nfunction useOptions(props: TimePickerProps | KeyboardTimePickerProps) {\n  const utils = useUtils();\n\n  return {\n    getDefaultFormat: () =>\n      pick12hOr24hFormat(props.format, props.ampm, {\n        '12h': utils.time12hFormat,\n        '24h': utils.time24hFormat,\n      }),\n  };\n}\n\nexport const TimePicker = makePickerWithState<TimePickerProps>({\n  useOptions,\n  Input: PureDateInput,\n  useState: usePickerState,\n  DefaultToolbarComponent: TimePickerToolbar,\n});\n\nexport const KeyboardTimePicker = makePickerWithState<KeyboardTimePickerProps>({\n  useOptions,\n  Input: KeyboardDateInput,\n  useState: useKeyboardPickerState,\n  DefaultToolbarComponent: TimePickerToolbar,\n  getCustomProps: props => ({\n    refuse: props.ampm ? /[^\\dap]+/gi : /[^\\d]+/gi,\n  }),\n});\n\nTimePicker.defaultProps = defaultProps;\n\nKeyboardTimePicker.defaultProps = defaultProps;\n"],"sourceRoot":""}